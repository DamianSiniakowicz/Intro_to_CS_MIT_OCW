MIT Intro to CS with Python
Unit 2 Lesson 1
****************************
Hash functions convert immutable arguments into integers within a fixed range

Hashing is how Python impliments dicts
Very efficient in time, not in space (because we prefer # buckets > bucket size)

Basically we have a list of lists. 
All integers n+x hash to the same bucket
Where x is a multiple of the number of buckets and n is a number 
between 0 and the number of buckets minus one  

i and k are integers
hash(i) -> 0 to k
hashing converts stuff into integers

a bucket is a list within a list
hashing allows us to look up buckets

*I think the point of hashing is that we if we have a database of strings we want
to add to and take away from, its faster to manage them if we have a list of lists
each containing copies of strings which we can access by indexing to the hashed val
than if we have a list of strings where we need to do a linear/bissection search
everytime we want to access a string.*

An infinite number of integers hash to any single bucket
When two elements hash one bucket they collide
We can resolve this with linear rehash

The complexity of member testing is O(n) where n = len(bucket)
it can go all the way up to n = total number of objects hashed

Fewer buckets = larger buckets (efficient in space)
More buckets = smaller buckets (efficient in time)
Hash functions' complexity can range from O(1) to O(n)
Usually we create O(1) hash functions, so, lotsa buckets
That's what Python does with dictionaries

Only immutable objects can be hashed. 
This is why dict keys only take immutable objects
The reason Python doesn't let us hash mutable objects is that if we modify an 
object already in a bucket, then its hash value will change, but it won't be
automatically removed from its old bucket and placed in a new, correct bucket. 

"And again, I don't care if you understand how the code works here"

Interpreter Errors not prompted by the user are built-in Exceptions
Unhandled Exceptions are errors that cause a script to crash

We can handle exceptions in try-except blocks. Flow of control technique
try is followed by some tests
if none raise an error we skip past the except block
if an error is raised then we run the except block

???Polymorphic function???

We can cause errors like this
raise TheErrorName('an error message')

???significance of the kind of error entered after except???
The kind of error tells Python which kind of errors to execute the except
block for. If no type is specified then the except block is executed for
all types of errors.

try:
	int('a')
except ValueError:
	raise ValueError('letters aren\'t ints')

Often used on user input

A polymorphic function is one that works on a variety of different input types

Module = collection of related functions
dot notation allows for multiple functions with same name

Class = collection of data and functions that operate on that data
A way to associate attributes with objects
A collection of objects with identical characteristics that form a type
object retains access to its functions wherever we move it.
examples: List is a (built-in) class with function append, String with strip
Attributes = data and functions associated with specific types of object.
data, functions, and class are all objects
Method = function associated with objects of a specific type.

Message Passing Metaphor
function passes message to object which interprets the message and does x

"Everything is an object."