MIT Intro to CS using Python

Unit 1 Lesson 1

*Declarative and Imperative Knowledge*

Declarative Knowledge is a fact. 
Y is the square root of X iff Y*Y == X

Imperative Knowledge is a recipe(algorithm)
For example: Take a guess G, if G*G not good enough
then do G = (G + X/G)/2
and keep doing this until you get within acceptable range


!!!Often we want answers that are 'good enough', not correct!!!

Algorithm = description of how to perform a computation. 
When we get a satisfactory answer: The algorithm has 'converged.'
Algorithms contain
instructions, flow control, and termination condition.

*Fixed program computer vs. stored program computer*

Fixed program computers are built(hardware) to do one thing. The computation possibilities are fixed.
Calculate square roots, decrypt messages, etc.

Stored Program computers
Instructions = Data
Instructions can produce data as well as new instructions.
The computer is a program called an interpreter. It can execute any set of 'legal' instructions.
Turing completenes. 6 primitive instructions.

A programming language provides a set of primitive instructions and control flow mechanisms. How they are combined is what distinguishes computer languages.

Syntax: Which series of characters and symbols constitute a valid string.
Ex. x = 2 + 3 is valid, x = 2 3 is not valid. 
Value Operation Value

Static Semantics: Which syntactic units are 'meaningful' 
Ex. 3 / 'abc' is syntactically correct, stat-semantically meaningless.
Does this operation take this value

Semantics: The meaning assigned to a string. Examples?
What are the semantics of x = 2 + 3 

No ambiguity in computer language.

Crash: program aborts. 
Never Stop: infinite loop. 
Wrong answer. lol: this can kill people.

*Interpreted vs. Compiled*

Compiled languages convert the code you write (source code) into a code more native to the hardware (object code), and only then run the program.

Interpreted languages do not do this conversion. 

Compiled languages are faster but they return error messages in object code. 

Turing

???What are the 6 primitive instructions???
if a computer contains these 6 capabilites, it can compute any computable problem (Turing completeness)
The 6 primitives are:
1.) move left
2.) move right
3.) do nothing
4.) erase current cell
5.) copy current cell
6.) print onto current cell
They refer to the universal turing model of a computer. A one dimensional infinitely long series of 0's and 1's. Or a 'tape' ?how would you fill in a hole?
lmao: ???halting problem???
not all problems are computable. Ex:
it is impossible to write a program that given another program, p, prints True iff p runs forever. That sounds like math.....
a program is turing complete if it can simulate universal turing machine. All modern computer languages are turing complete. They can all do the same exact things.
However, the design can vary considerably making it EASIER to do things with one language over another.
Primitives and Literals
Primitives = built in operations (+, sum(), .strip())
mathematical operations = infix operators
Literals = built in operators (1, 'avhys', 2.94, 'etc.')


MATLAB: Good for math
PHP: Good for web-spinning
C: Good for networking
Python: Jack of all trades


Guttag's book Intro

A fixed program computer no separation between hardware and software. They are one inseperable entity

stored program computers
META: program == data wtf

Interpreter: interprets code. How does it do this? It interprets Python code in terms of Python code? wtf

"a programming language is what we use to give a computer its marching orders" HA, so computer scientists are generals, huh?

Syntax: allowed ordering of operators and literals
Static Semantics: specification of valid operator/literal pairings
Semantics: The UNIQUE output produced by a specific ordering of specific operators and literals. Unique 1 to 1 mapping of expression to value

Low-Level Language = more literal, closer to machine code, closet to 1's and 0's
High-Level Language = more english, closer to human language, written in terms of a lower-level language (machine code, or another language written in terms of machine-code)
Ex. I believe Python is written in C, which in turn is written in machine code?

General vs. Targeted: is the language written for a specific task? 
Ex. A graphics manipulator might have operators only for image editing with other kinds of operators only accessible via a lower-level language?

Machine code is the stuff hardware reads. 1's and 0's?
Source code is the stuff a programmer writes

Interpreted Languages run source code. Error messages are clearer.
Compiled Languages 'compile' source code into a lower-level language before running it. less space, less time.

Criticism: if everything is an object then what the fuck does it mean to be an object? What is the distinguishing characteristic? It means nothing in and of itself. As they say in the book of tao: without ugly there is no beautiful







































