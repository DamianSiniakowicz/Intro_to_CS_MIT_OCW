MIT Intro to CS with Python

Unit 1 Lesson 6
****************************

Modular Abstraction: Basically, creating functions. 
Divide and Conquer: Break one big function into several smaller ones.
- small problems are easier to solve and functions easier to debug.
- small functions can be combined to solve big functions.

Recursion
- a way of describing problems
- a way of designing solutions(D&C)

Two parts

Base Case: direct answers
Recursive/Inductive Case: Reduce to simpler version of original problem plus other simple operations.

There can be more than one of each

Example: b**p, computing exponents
def powers(b, p):
    if p == 1:
        return b
    else:
        return b * powers(b, p - 1)

print powers(3, 3)

Note, this only works for powers >=1

Towers of Hanoi
You've got three pillars.
One pillar has a bunch of rings on it. 
Every ring has a different size.
They are stacked from largest to smallest.
Move the stack to another pillar without ever putting a big ontop a  small

With Recursion: To move a stack of size n, first move a stack of n - 1.

def Hanoi(n, r, b, y):
    if n == 1:
        print "move from " + r + " to " + b
    else:
        Hanoi(n - 1, r, y, b) 
        Hanoi(1, r, b, y)
        Hanoi(n - 1, y, b, r)

Hanoi(3, 'original', 'target', 'helper')

"""
Given Hanoi(3, 'original', 'target', 'helper')
n != 1 so we call:

    Hanoi(2, 'original', 'helper', 'target')
        n != 1 so:
        Hanoi(1, 'original', 'target', 'helper')
            print 'original to target'
        Hanoi(1, 'original', 'helper', 'target')
            print 'original to helper'    
        Hanoi(1, 'target', 'helper', 'original')
            print 'target to helper'
    Hanoi(1, 'original', 'target', 'helper')
        print 'original to target'

    Hanoi(2, 'helper', 'target', 'original')
        n != 1 so:
        Hanoi(1, 'helper', 'original', 'target')
            print 'helper to original'
        Hanoi(1, 'helper', 'target', 'original')
            print 'helper to target'
        Hanoi(1, 'original', 'target', 'helper')
            print 'original to target'
"""

Golden Ratio: the limit as x approches infinity of fib(x) / fib(x-1)
------------------------------------------------------------------

RECITATION NOTES

del list_name[index]
list_name.remove('object_name')
list_name.pop()

append allows you to append a literal or iterable to a list
extend allows you to append the objects in an iterable to a list

appending 'car' will add 'car'
extending 'car' will add 'c', 'a', 'r'
appending ['chicken', 'turkey'] will add ['chicken', 'turkey']
extending ['chicken', 'turkey'] will add 'chicken', 'turkey'


A = [1] * 10
print A: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
B = [[]] * 10
print B: [[], [], [], [], [], [], etc.]
C = [] * 10
print C: [] ???

Matrices with lists == cool

Dictionary keys must be unique.
An identical key would replace the old value.

You can't sort a dictionary buy you can sort a list of its keys and then iterate through the list if you want to do something.

You can also use dict_name.items() to create a list of tuples and then sort that list.

Factorials with Recursion

def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)

Note: When testing a recursive function, always start with the base case.

The number of unique recursive calls in each run == the number of required base cases.

def multiplicationz(x, y):
    if y > 0:
        if y == 1:
            return x
        else:
            return x + multiplicationz(x, y - 1)
    elif y < 0:
        if y == -1:
            return -x
        else:
            return -x + multiplicationz(x, y + 1)
    else:
        return 0

---------------
string.strip(chars)
removes some or all appearances in string of the chars specified in chars 
It works from the outside in. As soon as it runs into a character not mentioned in chars, it stops removing characters from that side.
Ex. 'wowow'.strip('w') returns 'owo'

dictionary.get(key, value) returns the key's actual value if the key exists in the dictionary, otherwise it adds it to the dictionary with the value specified in value

object.copy() produces a copy of an object








