MIT Intro to CS using Python

Unit 1 Lesson 1: Intro to Computers

*Declarative and Imperative Knowledge*

Declarative Knowledge is a fact. 
Y is the square root of X iff Y*Y == X

Imperative Knowledge is a recipe(algorithm)
For example: Take a guess G, if G*G not good enough
then do G = (G + X/G)/2
and keep doing this until you get within acceptable range


!!!Often we want answers that are 'good enough', not correct!!!

Algorithm = description of how to perform a computation. 
When we get a satisfactory answer: The algorithm has 'converged.'
Algorithms contain
instructions, flow control, and termination condition.

*Fixed program computer vs. stored program computer*

Fixed program computers are built(hardware) to do one thing. The computation possibilities are fixed.
Calculate square roots, decrypt messages, etc.

Stored Program computers
Instructions = Data
Instructions can produce data as well as new instructions.
The computer is a program called an interpreter. It can execute any set of 'legal' instructions.
Turing completenes. 6 primitive instructions.

A programming language provides a set of primitive instructions and control flow mechanisms. How they are combined is what distinguishes computer languages.

Syntax: Which series of characters and symbols constitute a valid string.
Ex. x = 2 + 3 is valid, x = 2 3 is not valid. 
Value Operation Value

Static Semantics: Which syntactic units are 'meaningful' 
Ex. 3 / 'abc' is syntactically correct, stat-semantically meaningless.
Does this operation take this value

Semantics: The meaning assigned to a string. Examples?
What are the semantics of x = 2 + 3 

No ambiguity in computer language.

Crash: program aborts. 
Never Stop: infinite loop. 
Wrong answer. lol: this can kill people.

*Interpreted vs. Compiled*

Compiled languages convert the code you write (source code) into a code more native to the hardware (object code), and only then run the program.

Interpreted languages do not do this conversion. 

Compiled languages are faster but they return error messages in object code. 

***Turing***

???What are the 6 primitive instructions???


---------------------------
MATLAB: Good for math
PHP: Good for web-spinning
C: Good for networking
Python: Jack of all trades


Guttag's book Intro

In a fixed program computer hardware and software are inseperable.

The software on a stored program computer can be manipulated without changing the hardware.
META: program == data wtf

Interpreter: interprets source code directly. How does it do this? Direct translation from Python to Machine Code?

"a programming language is what we use to give a computer its marching orders" HA, so computer scientists are generals, huh?

Syntax: allowed ordering of operators and literals
Static Semantics: specification of valid operator/literal pairings
Semantics: The UNIQUE output produced by a specific ordering of specific operators and literals. Unique 1 to 1 mapping of expression to value

Low-Level Language = more literal, closer to machine code, closer to 1's and 0's
High-Level Language = more english, closer to human language, written in terms of a lower-level language.
Ex. I believe Python is written in C, which in turn is written in machine code?

General vs. Targeted: is the language written for a specific task? 
Ex. A graphics manipulator might have operators only for image editing with other kinds of operators only accessible via a lower-level language?

Machine code is the stuff hardware reads. 1's and 0's?
Source code is the stuff a programmer writes

Interpreted Languages run source code. Error messages are clearer.
Compiled Languages 'compile' source code into a lower-level(machine code?) language before running it. less space, less time.

Markup language: a language used to represent data (ex. HTML). They are usually not Turing complete because they do not perform computations. Data is never changed?
Also called container and data description languages. Is this art? Are markup languages vehicles for artistic expression? 

Turing Machine Oracle Machine

A Turing Machine is an infinite array of cells and a 1-cell-wide interpreter.
Its 6 primitives are:
1.) move left
2.) move right
3.) do nothing
4.) erase current cell
5.) copy current cell
6.) print onto current cell ???(what if you copy onto an already filled cell?) Is combination of elements possible or are all possible values defined beforehand???
They refer to the universal turing model of a computer: the turing machine: A one dimensional infinitely long series of cells. 'tape' and a 1 cell wide interpreter 
If a program can simulate a turing machine then it is turing complete. It can compute any computable problem.
All modern computer languages are turing complete. They can all do the same exact things.
However, the design can vary considerably making it EASIER to do things with one language over another.

lmao: halting problem
not all problems are computable. Ex:
it is impossible to write a program that given another program, p, prints True iff p runs forever. That sounds... like math.....

"The machine can alter the scanned symbol and its behavior is in part determined by that symbol" - Turing
examples? So we need 6 commands... What about addition? How is addition defined? ???What happens if you copy a cell while the interpreter already has another cell stored???

Primitives and Literals
Primitives = built in operations (+, sum(), .strip())
mathematical operations = infix operators
Literals = built in operators (1, 'avhys', 2.94, 'etc.')

A Turing Reduction is a program that solves 'problem' A in terms of another problem B.
"More formally, a turing reduction of problem A to problem B is THE COMPUTATION of A with an oracle machine for B. (ex. solving A in terms of a function that solves B)

An Oracle Machine is a turing machine with an oracle attached to it. The oracle can solve any problem, computable or not(wtf,how??).
Is an oracle machine just a turing machine with a turing machine on it. The only different I see is that an oracle can solve non-computable problems.
Is an oracle just a shortcut? When the turing machine switches to ask mode, the oracle performs a calculation in one step. Then the turing machine switches to response mode
at which time the oracle's answer is retreived.

Oracles can solve 2 kinds of problems
Decision Problems: Given a set and an element, tell us whether the element is in the set.
Function Problems: A function from elements to elements.




QUESTIONS
???How does an oracle machine solve non-computable problems???
"The oracle, in this context, is an entity capable of solving some problem, which for example may be a decision problem or a function problem. The problem does not have to be computable. The oracle is simply a "black box" that is able to produce a solution for any instance of a given computational problem" - http://en.wikipedia.org/wiki/Oracle_machine
What is an example of a computation for an incomputable problem? Is the oracle able to recognize that a problem is undecidable/incomputable?
???Is the 'tape alphabet' infinite???
If it wasn't then wouldn't there always exist numbers it couldn't understand since numbers are infinite? Suppose only the numbers 1 to 10 existed. How could 11 be produced without already existing in the alphabet?

 
